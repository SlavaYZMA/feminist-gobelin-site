<!DOCTYPE html>
<html lang="en" class="notranslate" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <title>Digital Tapestry | Feminist Gobelin</title>
    <meta name="description" content="Ask questions about feminism and get answers from our AI model, trained on multilingual resources.">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://cdn.wegic.ai/assets/email/wegic-large-preview.png">
    <meta property="og:url" content="https://feminist-gobelin-site.netlify.app">
    <meta property="og:title" content="Digital Tapestry | Feminist Gobelin">
    <meta property="og:description" content="Ask questions about feminism and get answers from our AI model, trained on multilingual resources.">
    <meta property="og:image" content="https://cdn.wegic.ai/assets/email/wegic-large-preview.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.15/babel.min.js"></script>
    <style>
        :root {
            --primary-6: #165DF5; /* Blue for buttons and accents */
            --color-text-1: #333; /* Primary text */
            --gray-1: #F7F8FA; /* Input background */
            --gray-9: #272E3B; /* Secondary text */
            --color-neutral-3: rgba(0,0,0,0.1); /* Borders */
            --user-bg: #E6F0FA; /* User message background */
            --assistant-bg: #F7F6F5; /* Assistant message background */
        }
        body {
            margin: 0;
            background: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', system-ui, Arial, sans-serif;
            color: var(--color-text-1);
        }
        .container {
            display: flex;
            flex-direction: column;
            width: 90vw;
            max-width: 800px;
            gap: 1.5rem;
            padding: 50px 120px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .chat-container {
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 16px;
            border-radius: 12px;
            background: #fff;
        }
        .message {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            max-width: 80%;
            padding: 16px;
            border-radius: 12px;
            font-size: 15px;
            line-height: 24px;
            color: rgba(0,0,0,0.8);
            position: relative;
        }
        .message.user {
            align-self: flex-end;
            background: var(--user-bg);
        }
        .message.assistant {
            align-self: flex-start;
            background: var(--assistant-bg);
        }
        .message:hover .message-actions {
            opacity: 1;
        }
        .message-timestamp {
            font-size: 12px;
            color: var(--gray-9);
            margin-top: 4px;
        }
        .message-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .action-button {
            background: transparent;
            border: none;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .action-button:hover {
            transform: scale(1.1);
        }
        .action-button:active {
            transform: scale(0.9);
        }
        .edit-input {
            width: 100%;
            background: var(--gray-1);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 12px;
            padding: 12px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            line-height: 20px;
            color: var(--color-text-1);
            resize: none;
            overflow: hidden;
        }
        .edit-input:focus {
            outline: none;
            border-color: var(--primary-6);
            box-shadow: 0 0 0 2px rgba(22,93,255,0.2);
        }
        .clear-history {
            align-self: center;
            background: transparent;
            border: none;
            color: var(--primary-6);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .clear-history:hover {
            color: #000;
        }
        .prompt-container {
            position: relative;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 0.75rem;
        }
        .submit-input {
            flex-grow: 1;
            background: var(--gray-1);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 12px;
            padding: 12px 40px 12px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            line-height: 20px;
            color: var(--color-text-1);
            resize: none;
            overflow: hidden;
            min-height: 40px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .submit-input:focus {
            outline: none;
            border-color: var(--primary-6);
            box-shadow: 0 0 0 2px rgba(22,93,255,0.2);
        }
        .submit-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #000;
            border: 0;
            border-radius: 12px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 10px 0 rgba(0,0,0,0.04) inset, 0 -1px 0.5px 0.5px rgba(255,255,255,0.2) inset, 0 0.5px 2px 0.5px rgba(255,255,255,0.2) inset, 0 -0.5px 0.5px 0 rgba(255,255,255,0.2) inset, 0 0.5px 0 0 rgba(255,255,255,0.2) inset, 0 0.5px 0.5px 0 rgba(0,0,0,0.2), 0 0 0 0.5px #000;
            cursor: pointer;
            transition: all 0.1s linear;
        }
        .submit-button:hover:not(:disabled) {
            transform: translateY(-50%) scale(1.1);
        }
        .submit-button:active:not(:disabled) {
            transform: translateY(-50%) scale(0.9);
        }
        .submit-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-6);
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .details-toggle {
            cursor: pointer;
            color: var(--primary-6);
            font-size: 13px;
            font-weight: 500;
            transition: color 0.2s ease;
        }
        .details-toggle:hover {
            color: #000;
        }
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 576px;
            background: #fff;
            border-radius: 32px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            padding: 20px;
            animation: zoomModal-enter 0.4s cubic-bezier(0.3,1.3,0.3,1);
        }
        @keyframes zoomModal-enter {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .modal-content {
            padding: 24px 20px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            height: 48px;
            border-bottom: 1px solid var(--color-neutral-3);
        }
        .modal-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--color-text-1);
            flex: 1;
            text-align: center;
        }
        .modal-close {
            position: absolute;
            top: 18px;
            right: 20px;
            font-size: 12px;
            cursor: pointer;
            color: var(--color-text-1);
        }
        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid var(--color-neutral-3);
        }
        .modal-button {
            background: var(--primary-6);
            color: #fff;
            border: 0;
            border-radius: 12px;
            padding: 0 20px;
            height: 40px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.1s linear;
        }
        .modal-button:hover {
            transform: scale(1.05);
        }
        .modal-button:active {
            transform: scale(0.95);
        }
        .modal-input, .modal-select {
            background: var(--gray-1);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 12px;
            padding: 12px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            line-height: 20px;
            color: var(--color-text-1);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .modal-input:focus, .modal-select:focus {
            outline: none;
            border-color: var(--primary-6);
            box-shadow: 0 0 0 2px rgba(22,93,255,0.2);
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            width: 100vw;
            height: 100vh;
        }
        @media (max-width: 768px) {
            .container {
                padding: 30px 24px;
                max-width: 95%;
            }
            .chat-container {
                max-height: 300px;
                padding: 12px;
            }
            .message {
                font-size: 14px;
                padding: 12px;
                max-width: 90%;
            }
            .submit-input, .modal-input, .modal-select, .edit-input {
                font-size: 12px;
                padding: 10px 36px 10px 10px;
            }
            .submit-button, .modal-button, .action-button {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }
            .spinner {
                width: 18px;
                height: 18px;
                border-width: 1.5px;
            }
            .modal {
                width: 360px;
                border-radius: 20px;
            }
            .modal-content {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        function GobelinApp() {
            const [userId] = React.useState('user_' + Math.random().toString(36).substr(2, 9));
            const [name, setName] = React.useState(localStorage.getItem('name') || '');
            const [tempName, setTempName] = React.useState(name);
            const [country, setCountry] = React.useState(localStorage.getItem('country') || '');
            const [tempCountry, setTempCountry] = React.useState(country);
            const [city, setCity] = React.useState(localStorage.getItem('city') || '');
            const [tempCity, setTempCity] = React.useState(city);
            const [prompt, setPrompt] = React.useState('');
            const [messages, setMessages] = React.useState(() => {
                const saved = localStorage.getItem('chatHistory');
                return saved ? JSON.parse(saved) : [];
            });
            const [isLoading, setIsLoading] = React.useState(false);
            const [showDetails, setShowDetails] = React.useState(false);
            const [language, setLanguage] = React.useState('en');
            const [editingIndex, setEditingIndex] = React.useState(null);
            const [editText, setEditText] = React.useState('');
            const canvasRef = React.useRef(null);
            const threadsRef = React.useRef([]);
            const abortControllerRef = React.useRef(null);
            const chatContainerRef = React.useRef(null);

            // Мультиязычные тексты
            const translations = {
                en: {
                    placeholder: "Ask a question about feminism...",
                    detailsToggle: { open: "Hide Details", closed: "Show Details" },
                    namePlaceholder: "Name (e.g., Anna)",
                    countryPlaceholder: "Country",
                    cityPlaceholder: "City",
                    save: "Save",
                    reset: "Reset",
                    clear: "Clear",
                    clearHistory: "Clear History",
                    regenerate: "Regenerate",
                    copy: "Copy",
                    share: "Share",
                    edit: "Edit",
                    errorResponse: "An error occurred. Please try again later.",
                    fallbackResponse: "Feminism is a movement advocating for equal rights and opportunities for women across social, political, and economic spheres. (Please verify information with official sources.)",
                    modalTitle: "User Details"
                },
                ru: {
                    placeholder: "Задайте вопрос о феминизме...",
                    detailsToggle: { open: "Скрыть детали", closed: "Показать детали" },
                    namePlaceholder: "Имя (например, Анна)",
                    countryPlaceholder: "Страна",
                    cityPlaceholder: "Город",
                    save: "Сохранить",
                    reset: "Сбросить",
                    clear: "Очистить",
                    clearHistory: "Очистить историю",
                    regenerate: "Перегенерировать",
                    copy: "Скопировать",
                    share: "Поделиться",
                    edit: "Редактировать",
                    errorResponse: "Произошла ошибка. Пожалуйста, попробуйте снова.",
                    fallbackResponse: "Феминизм — это движение за равные права и возможности для женщин в социальной, политической и экономической сферах. (Пожалуйста, проверьте информацию в официальных источниках.)",
                    modalTitle: "Данные пользователя"
                },
                es: {
                    placeholder: "Haz una pregunta sobre feminismo...",
                    detailsToggle: { open: "Ocultar detalles", closed: "Mostrar detalles" },
                    namePlaceholder: "Nombre (ej., Anna)",
                    countryPlaceholder: "País",
                    cityPlaceholder: "Ciudad",
                    save: "Guardar",
                    reset: "Restablecer",
                    clear: "Limpiar",
                    clearHistory: "Limpiar historial",
                    regenerate: "Regenerar",
                    copy: "Copiar",
                    share: "Compartir",
                    edit: "Editar",
                    errorResponse: "Ocurrió un error. Por favor, intenta de nuevo.",
                    fallbackResponse: "El feminismo es un movimiento que aboga por los derechos y oportunidades iguales para las mujeres en las esferas social, política y económica. (Por favor, verifica la información con fuentes oficiales.)",
                    modalTitle: "Detalles del usuario"
                }
            };

            // Список стран и городов
            const countries = [
                'Afghanistan', 'Albania', 'Argentina', 'Australia', 'Brazil',
                'Canada', 'China', 'France', 'Germany', 'India', 'Mexico',
                'Russia', 'Spain', 'United Kingdom', 'United States', 'Zimbabwe'
            ];
            const citiesByCountry = {
                'Afghanistan': ['Kabul', 'Kandahar', 'Herat'],
                'Albania': ['Tirana', 'Durrës', 'Vlorë'],
                'Argentina': ['Buenos Aires', 'Córdoba', 'Rosario'],
                'Australia': ['Sydney', 'Melbourne', 'Brisbane'],
                'Brazil': ['São Paulo', 'Rio de Janeiro', 'Brasília'],
                'Canada': ['Toronto', 'Montreal', 'Vancouver'],
                'China': ['Beijing', 'Shanghai', 'Guangzhou'],
                'France': ['Paris', 'Marseille', 'Lyon'],
                'Germany': ['Berlin', 'Munich', 'Hamburg'],
                'India': ['Delhi', 'Mumbai', 'Bangalore'],
                'Mexico': ['Mexico City', 'Guadalajara', 'Monterrey'],
                'Russia': ['Moscow', 'Saint Petersburg', 'Novosibirsk'],
                'Spain': ['Madrid', 'Barcelona', 'Valencia'],
                'United Kingdom': ['London', 'Manchester', 'Birmingham'],
                'United States': ['New York', 'Los Angeles', 'Chicago'],
                'Zimbabwe': ['Harare', 'Bulawayo', 'Chitungwiza']
            };

            // Сохранение данных
            const saveData = () => {
                setName(tempName);
                setCountry(tempCountry);
                setCity(tempCity);
                localStorage.setItem('name', tempName);
                localStorage.setItem('country', tempCountry);
                localStorage.setItem('city', tempCity);
                setShowDetails(false);
            };

            // Сброс данных
            const resetData = () => {
                setTempName('');
                setTempCountry('');
                setTempCity('');
                setName('');
                setCountry('');
                setCity('');
                localStorage.removeItem('name');
                localStorage.removeItem('country');
                localStorage.removeItem('city');
                setShowDetails(false);
            };

            // Очистка одного сообщения
            const clearMessage = (index) => {
                const newMessages = messages.filter((_, i) => i !== index);
                setMessages(newMessages);
                localStorage.setItem('chatHistory', JSON.stringify(newMessages));
                if (newMessages.length === 0) {
                    threadsRef.current = [];
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };

            // Очистка истории
            const clearHistory = () => {
                setMessages([]);
                localStorage.removeItem('chatHistory');
                threadsRef.current = [];
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            };

            // Редактирование сообщения
            const startEditing = (index, content) => {
                setEditingIndex(index);
                setEditText(content);
            };

            const saveEdit = (index) => {
                const fullPrompt = name && city && country ? `${name} from ${city}, ${country}: ${editText}` : editText;
                const newMessages = [...messages];
                newMessages[index] = { ...newMessages[index], content: editText, fullPrompt };
                setMessages(newMessages);
                localStorage.setItem('chatHistory', JSON.stringify(newMessages));
                setEditingIndex(null);
                setEditText('');
            };

            // Копирование текста
            const copyText = (text) => {
                navigator.clipboard.writeText(text);
                alert(translations[language].copy + 'ed!');
            };

            // Поделиться ответом
            const shareResponse = (content) => {
                const shareText = `${content}\n\nGenerated by Feminist Gobelin: https://feminist-gobelin-site.netlify.app`;
                navigator.clipboard.writeText(shareText);
                alert(translations[language].share + ' link copied!');
            };

            // Регенерация ответа
            const regenerateResponse = async (index) => {
                const promptMessage = messages[index - 1];
                if (!promptMessage || promptMessage.role !== 'user') return;
                setIsLoading(true);
                abortControllerRef.current = new AbortController();
                try {
                    const threadTypes = ['line', 'wave', 'text', 'pixels', 'fiber', 'glitch', 'spiral'];
                    const type = threadTypes[Math.floor(Math.random() * threadTypes.length)];
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    drawThread(ctx, promptMessage.content, type);
                    animateThreads(ctx);
                    const res = await fetch('https://SlavaYZMA-feminist-gobelin-server.hf.space/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: userId, name, country, city, prompt: promptMessage.content }),
                        signal: abortControllerRef.current.signal
                    });
                    const data = await res.json();
                    let responseText = data.response || 'No response received.';
                    const fullPrompt = promptMessage.fullPrompt || promptMessage.content;
                    if (responseText.startsWith(fullPrompt)) {
                        responseText = responseText.substring(fullPrompt.length).trim();
                    }
                    if (responseText.length < 10 || responseText.includes('What is it about')) {
                        responseText = translations[language].fallbackResponse;
                    }
                    const newMessages = [...messages];
                    newMessages[index] = { role: 'assistant', content: responseText, timestamp: new Date().toLocaleString() };
                    setMessages(newMessages);
                    localStorage.setItem('chatHistory', JSON.stringify(newMessages));
                } catch (error) {
                    if (error.name === 'AbortError') {
                        threadsRef.current = [];
                        const canvas = canvasRef.current;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        console.error('Error:', error);
                        const newMessages = [...messages];
                        newMessages[index] = { role: 'assistant', content: translations[language].errorResponse, timestamp: new Date().toLocaleString() };
                        setMessages(newMessages);
                        localStorage.setItem('chatHistory', JSON.stringify(newMessages));
                    }
                } finally {
                    setIsLoading(false);
                    abortControllerRef.current = null;
                }
            };

            // Определение эмоции
            const detectEmotion = (text) => {
                const positive = ['support', 'help', 'love', 'joy', 'поддержка', 'помощь', 'любовь', 'радость', 'apoyo', 'ayuda', 'amor', 'alegría'];
                const negative = ['violence', 'fear', 'pain', 'насилие', 'страх', 'боль', 'violencia', 'miedo', 'dolor'];
                return positive.some(word => text.toLowerCase().includes(word)) ? 'positive' :
                       negative.some(word => text.toLowerCase().includes(word)) ? 'negative' : 'neutral';
            };

            // Рисование нитей
            const drawThread = (ctx, input, type) => {
                const length = Math.min(input.length * 15, ctx.canvas.height);
                const emotion = detectEmotion(input);
                const isHorizontal = Math.random() > 0.5;
                const padding = 50;
                const startX = isHorizontal ? padding : Math.random() * (ctx.canvas.width - 2 * padding) + padding;
                const startY = isHorizontal ? Math.random() * (ctx.canvas.height - 2 * padding) + padding : padding;
                const endX = isHorizontal ? ctx.canvas.width - padding : startX;
                const endY = isHorizontal ? startY : length + padding;
                const color = emotion === 'positive' ? '#3b82f6' : emotion === 'negative' ? '#ec4899' : '#165DF5';
                const thickness = Math.min(input.length / 5, 6);
                let thread = { type, startX, startY, endX, endY, color, thickness, opacity: 0, progress: 0 };

                switch (type) {
                    case 'line':
                        thread = { ...thread, controlX: (startX + endX) / 2, controlY: (startY + endY) / 2 };
                        break;
                    case 'wave':
                        thread = { ...thread, amplitude: 50 + Math.random() * 50, frequency: 0.02 + Math.random() * 0.03 };
                        break;
                    case 'text':
                        thread = { ...thread, text: input.slice(0, 10), fontSize: 12 + input.length / 10 };
                        break;
                    case 'pixels':
                        thread = { ...thread, particleCount: 20 + input.length * 2 };
                        break;
                    case 'fiber':
                        thread = { ...thread, segments: 5 + Math.floor(input.length / 10) };
                        break;
                    case 'glitch':
                        thread = { ...thread, glitchOffset: 5 + Math.random() * 10 };
                        break;
                    case 'spiral':
                        thread = { ...thread, radius: 20 + input.length, turns: 2 + input.length / 20 };
                        break;
                }

                threadsRef.current.push(thread);
                if (threadsRef.current.length > 30) {
                    threadsRef.current.shift();
                }
            };

            // Анимация нитей
            const animateThreads = (ctx) => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                threadsRef.current = threadsRef.current.filter(thread => thread.progress < 1);
                threadsRef.current.forEach((thread, index) => {
                    thread.progress = Math.min(thread.progress + 0.02, 1);
                    thread.opacity = thread.progress < 0.8 ? thread.progress : Math.max(1 - (thread.progress - 0.8) / 0.2, 0);
                    ctx.globalAlpha = thread.opacity;

                    ctx.beginPath();
                    switch (thread.type) {
                        case 'line':
                            ctx.moveTo(thread.startX, thread.startY);
                            ctx.quadraticCurveTo(thread.controlX, thread.controlY, thread.startX + (thread.endX - thread.startX) * thread.progress, thread.startY + (thread.endY - thread.startY) * thread.progress);
                            ctx.strokeStyle = thread.color;
                            ctx.lineWidth = thread.thickness;
                            ctx.stroke();
                            break;
                        case 'wave':
                            ctx.moveTo(thread.startX, thread.startY);
                            for (let x = 0; x <= (thread.endX - thread.startX) * thread.progress; x += 5) {
                                const y = Math.sin(x * thread.frequency) * thread.amplitude;
                                ctx.lineTo(thread.startX + x, thread.startY + y);
                            }
                            ctx.strokeStyle = thread.color;
                            ctx.lineWidth = thread.thickness;
                            ctx.stroke();
                            break;
                        case 'text':
                            ctx.font = `${thread.fontSize}px Inter`;
                            ctx.fillStyle = thread.color;
                            ctx.fillText(thread.text, thread.startX, thread.startY + (thread.endY - thread.startY) * thread.progress);
                            break;
                        case 'pixels':
                            for (let i = 0; i < thread.particleCount; i++) {
                                const t = i / thread.particleCount;
                                if (t <= thread.progress) {
                                    const x = thread.startX + (thread.endX - thread.startX) * t;
                                    const y = thread.startY + (thread.endY - thread.startY) * t + (Math.random() - 0.5) * 10;
                                    ctx.fillStyle = thread.color;
                                    ctx.fillRect(x, y, thread.thickness / 2, thread.thickness / 2);
                                }
                            }
                            break;
                        case 'fiber':
                            for (let i = 0; i < thread.segments; i++) {
                                const t = i / thread.segments;
                                if (t <= thread.progress) {
                                    const x = thread.startX + (thread.endX - thread.startX) * t;
                                    const y = thread.startY + (thread.endY - thread.startY) * t + (Math.random() - 0.5) * 5;
                                    ctx.beginPath();
                                    ctx.moveTo(x, y);
                                    ctx.lineTo(x + 5, y + 5);
                                    ctx.strokeStyle = thread.color;
                                    ctx.lineWidth = thread.thickness / 2;
                                    ctx.stroke();
                                }
                            }
                            break;
                        case 'glitch':
                            ctx.moveTo(thread.startX, thread.startY);
                            ctx.lineTo(thread.startX + (thread.endX - thread.startX) * thread.progress + (Math.random() - 0.5) * thread.glitchOffset, thread.startY + (thread.endY - thread.startY) * thread.progress);
                            ctx.strokeStyle = thread.color;
                            ctx.lineWidth = thread.thickness;
                            ctx.setLineDash([5, 5]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            break;
                        case 'spiral':
                            ctx.moveTo(thread.startX, thread.startY);
                            for (let t = 0; t < thread.progress * thread.turns * 2 * Math.PI; t += 0.1) {
                                const r = thread.radius * t / (thread.turns * 2 * Math.PI);
                                const x = thread.startX + r * Math.cos(t);
                                const y = thread.startY + r * Math.sin(t);
                                ctx.lineTo(x, y);
                            }
                            ctx.strokeStyle = thread.color;
                            ctx.lineWidth = thread.thickness;
                            ctx.stroke();
                            break;
                    }
                    ctx.globalAlpha = 1;
                });
                if (threadsRef.current.length > 0) {
                    requestAnimationFrame(() => animateThreads(ctx));
                }
            };

            // Инициализация canvas и прокрутка чата
            React.useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const handleResize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Прокрутка вниз при добавлении сообщений
            React.useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
                localStorage.setItem('chatHistory', JSON.stringify(messages));
            }, [messages]);

            // Обработка отправки и отмены
            const handleSubmit = async () => {
                if (!prompt) return;
                const timestamp = new Date().toLocaleString();
                const fullPrompt = name && city && country ? `${name} from ${city}, ${country}: ${prompt}` : prompt;
                setMessages([...messages, { role: 'user', content: prompt, fullPrompt, timestamp }]);
                setIsLoading(true);
                setPrompt('');
                abortControllerRef.current = new AbortController();
                try {
                    const threadTypes = ['line', 'wave', 'text', 'pixels', 'fiber', 'glitch', 'spiral'];
                    const type = threadTypes[Math.floor(Math.random() * threadTypes.length)];
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    drawThread(ctx, prompt, type);
                    animateThreads(ctx);
                    const res = await fetch('https://SlavaYZMA-feminist-gobelin-server.hf.space/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: userId, name, country, city, prompt }),
                        signal: abortControllerRef.current.signal
                    });
                    const data = await res.json();
                    let responseText = data.response || 'No response received.';
                    if (responseText.startsWith(fullPrompt)) {
                        responseText = responseText.substring(fullPrompt.length).trim();
                    }
                    if (responseText.length < 10 || responseText.includes('What is it about')) {
                        responseText = translations[language].fallbackResponse;
                    }
                    setMessages(prev => [...prev, { role: 'assistant', content: responseText, timestamp: new Date().toLocaleString() }]);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        setMessages(prev => prev.filter((_, i) => i !== prev.length - 1));
                        threadsRef.current = [];
                        const canvas = canvasRef.current;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        console.error('Error:', error);
                        setMessages(prev => [...prev, { role: 'assistant', content: translations[language].errorResponse, timestamp: new Date().toLocaleString() }]);
                    }
                } finally {
                    setIsLoading(false);
                    abortControllerRef.current = null;
                }
            };

            // Отмена запроса
            const cancelRequest = () => {
                if (abortControllerRef.current) {
                    abortControllerRef.current.abort();
                    setIsLoading(false);
                    setMessages(prev => prev.filter((_, i) => i !== prev.length - 1));
                    threadsRef.current = [];
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };

            return (
                <div className="container">
                    <select
                        className="modal-select"
                        value={language}
                        onChange={(e) => setLanguage(e.target.value)}
                        style={{ width: '150px', alignSelf: 'center' }}
                    >
                        <option value="en">English</option>
                        <option value="ru">Русский</option>
                        <option value="es">Español</option>
                    </select>
                    {messages.length > 0 && (
                        <>
                            <div className="chat-container" ref={chatContainerRef}>
                                {messages.map((msg, index) => (
                                    <div key={index} className={`message ${msg.role}`}>
                                        {editingIndex === index && msg.role === 'user' ? (
                                            <div>
                                                <textarea
                                                    className="edit-input"
                                                    value={editText}
                                                    onChange={(e) => setEditText(e.target.value)}
                                                    rows={Math.max(1, editText.split('\n').length)}
                                                    style={{ resize: 'none', overflow: 'hidden' }}
                                                    onKeyDown={(e) => {
                                                        if (e.key === 'Enter' && !e.shiftKey) {
                                                            e.preventDefault();
                                                            saveEdit(index);
                                                        }
                                                    }}
                                                />
                                                <div className="message-actions" style={{ opacity: 1, position: 'static', marginTop: '8px' }}>
                                                    <button
                                                        onClick={() => saveEdit(index)}
                                                        className="action-button"
                                                        aria-label="Save Edit"
                                                    >
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                            <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
                                                        </svg>
                                                    </button>
                                                    <button
                                                        onClick={() => setEditingIndex(null)}
                                                        className="action-button"
                                                        aria-label="Cancel Edit"
                                                    >
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                                        </svg>
                                                    </button>
                                                </div>
                                            </div>
                                        ) : (
                                            <>
                                                {msg.content}
                                                <div className="message-timestamp">{msg.timestamp}</div>
                                                <div className="message-actions">
                                                    {msg.role === 'user' && (
                                                        <button
                                                            onClick={() => startEditing(index, msg.content)}
                                                            className="action-button"
                                                            aria-label={translations[language].edit}
                                                        >
                                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                                <path strokeLinecap="round" strokeLinejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                                            </svg>
                                                        </button>
                                                    )}
                                                    <button
                                                        onClick={() => copyText(msg.content)}
                                                        className="action-button"
                                                        aria-label={translations[language].copy}
                                                    >
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                            <path strokeLinecap="round" strokeLinejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                                        </svg>
                                                    </button>
                                                    {msg.role === 'assistant' && (
                                                        <>
                                                            <button
                                                                onClick={() => regenerateResponse(index)}
                                                                className="action-button"
                                                                aria-label={translations[language].regenerate}
                                                                disabled={isLoading}
                                                            >
                                                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                                                </svg>
                                                            </button>
                                                            <button
                                                                onClick={() => shareResponse(msg.content)}
                                                                className="action-button"
                                                                aria-label={translations[language].share}
                                                            >
                                                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                                                                </svg>
                                                            </button>
                                                        </>
                                                    )}
                                                    <button
                                                        onClick={() => clearMessage(index)}
                                                        className="action-button"
                                                        aria-label={translations[language].clear}
                                                    >
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                                        </svg>
                                                    </button>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                ))}
                            </div>
                            <button
                                onClick={clearHistory}
                                className="clear-history"
                                aria-label={translations[language].clearHistory}
                            >
                                {translations[language].clearHistory}
                            </button>
                        </>
                    )}
                    <div className="prompt-container">
                        <textarea
                            className="submit-input"
                            value={prompt}
                            onChange={(e) => {
                                setPrompt(e.target.value);
                                e.target.style.height = "auto";
                                e.target.style.height = e.target.scrollHeight + "px";
                            }}
                            placeholder={translations[language].placeholder}
                            rows={1}
                            style={{ resize: "none", overflow: "hidden" }}
                            onKeyDown={(e) => {
                                if (e.key === "Enter" && !e.shiftKey) {
                                    e.preventDefault();
                                    if (!isLoading) {
                                        handleSubmit();
                                    } else {
                                        cancelRequest();
                                    }
                                }
                            }}
                        />
                        <button
                            onClick={isLoading ? cancelRequest : handleSubmit}
                            disabled={!prompt && !isLoading}
                            className="submit-button"
                            aria-label={isLoading ? "Cancel" : "Submit"}
                        >
                            {isLoading ? (
                                <div className="spinner"></div>
                            ) : (
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fff" strokeWidth="2">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                            )}
                        </button>
                    </div>
                    <span
                        className="details-toggle"
                        onClick={() => setShowDetails(true)}
                        role="button"
                        tabIndex={0}
                        onKeyPress={(e) => e.key === 'Enter' && setShowDetails(true)}
                        aria-expanded={showDetails}
                        aria-label={translations[language].detailsToggle[showDetails ? 'open' : 'closed']}
                    >
                        {translations[language].detailsToggle[showDetails ? 'open' : 'closed']}
                    </span>
                    {showDetails && (
                        <div className="modal">
                            <div className="modal-header">
                                <span className="modal-title">{translations[language].modalTitle}</span>
                                <span
                                    className="modal-close"
                                    onClick={() => setShowDetails(false)}
                                    role="button"
                                    tabIndex={0}
                                    onKeyPress={(e) => e.key === 'Enter' && setShowDetails(false)}
                                    aria-label="Close"
                                >
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </span>
                            </div>
                            <div className="modal-content">
                                <input
                                    className="modal-input"
                                    type="text"
                                    value={tempName}
                                    onChange={(e) => setTempName(e.target.value)}
                                    placeholder={translations[language].namePlaceholder}
                                />
                                <select
                                    className="modal-select"
                                    value={tempCountry}
                                    onChange={(e) => { setTempCountry(e.target.value); setTempCity(''); }}
                                >
                                    <option value="">{translations[language].countryPlaceholder}</option>
                                    {countries.map((c) => (
                                        <option key={c} value={c}>{c}</option>
                                    ))}
                                </select>
                                <select
                                    className="modal-select"
                                    value={tempCity}
                                    onChange={(e) => setTempCity(e.target.value)}
                                    disabled={!tempCountry}
                                >
                                    <option value="">{translations[language].cityPlaceholder}</option>
                                    {(citiesByCountry[tempCountry] || []).map((c) => (
                                        <option key={c} value={c}>{c}</option>
                                    ))}
                                </select>
                            </div>
                            <div className="modal-footer">
                                <button
                                    onClick={saveData}
                                    className="modal-button"
                                    aria-label={translations[language].save}
                                >
                                    {translations[language].save}
                                </button>
                                <button
                                    onClick={resetData}
                                    className="modal-button"
                                    aria-label={translations[language].reset}
                                >
                                    {translations[language].reset}
                                </button>
                            </div>
                        </div>
                    )}
                    <canvas ref={canvasRef}></canvas>
                </div>
            );
        }

        ReactDOM.render(<GobelinApp />, document.getElementById('root'));
    </script>
</body>
</html>
